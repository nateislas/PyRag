---
description: Comprehensive Python development standards and best practices for consistent, maintainable code
globs:
  - "**/*.py"
  - "**/*.pyi"
  - "**/pyproject.toml"
  - "**/requirements*.txt"
  - "**/setup.py"
  - "**/Pipfile"
alwaysApply: true
---

# Python Development Standards

## Core Principles
- **Code readability is paramount** - Write code that tells a story
- **Consistency over cleverness** - Favor readable, maintainable solutions
- **Fail fast and clearly** - Make errors obvious and informative
- **Test-driven development** - Write tests alongside implementation

## Code Style & Formatting

### PEP 8 Compliance
- **STRICTLY follow PEP 8 guidelines** with modern refinements
- Use 4 spaces for indentation (never tabs or mixed)
- Maximum line length: 88 characters (Black formatter standard)
- Use 79 characters for comments and docstrings
- Blank lines: 2 before top-level functions/classes, 1 before methods

### Naming Conventions
- `snake_case` for variables, functions, modules, and packages
- `PascalCase` for classes and exceptions
- `UPPER_CASE` for module-level constants
- `_single_leading_underscore` for internal use
- `__double_leading_underscore` for name mangling (rare)
- Avoid single character names except for counters (`i`, `j`) and coordinates (`x`, `y`)

### Import Organization
```python
# 1. Standard library imports
import os
import sys
from pathlib import Path

# 2. Third-party imports  
import numpy as np
import pandas as pd
from requests import Session

# 3. Local application imports
from myapp.core import BaseClass
from myapp.utils import helper_function
```

## Type Hints & Static Analysis

### Comprehensive Type Annotations
- **Always use type hints** for function signatures
- Use `typing` for complex types, `collections.abc` for abstract types
- Prefer built-in generic types when available (Python 3.9+)
- Use `TypeVar` for generic functions and classes

```python
from typing import Optional, Union, List, Dict, Any, TypeVar, Protocol
from collections.abc import Callable, Iterator

T = TypeVar('T')

def process_items(
    items: list[dict[str, Any]], 
    processor: Callable[[dict[str, Any]], T]
) -> list[T]:
    """Process a list of items with a given processor function."""
    return [processor(item) for item in items]
```

### Modern Type Hints (Python 3.10+)
- Use `X | Y` instead of `Union[X, Y]`
- Use `X | None` instead of `Optional[X]`
- Leverage `match/case` statements for type narrowing

## Error Handling & Logging

### Exception Management
- **Never use bare `except:`** - always specify exception types
- Create custom exceptions for domain-specific errors
- Use exception chaining with `raise ... from ...`
- Handle exceptions at the appropriate level

```python
import logging
from typing import Optional

logger = logging.getLogger(__name__)

class DataProcessingError(Exception):
    """Raised when data processing fails."""
    pass

def load_config(path: str) -> dict[str, Any]:
    """Load configuration from file."""
    try:
        with open(path, 'r') as f:
            return json.load(f)
    except FileNotFoundError as e:
        logger.error(f"Configuration file not found: {path}")
        raise DataProcessingError(f"Missing config: {path}") from e
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in config file: {e}")
        raise DataProcessingError(f"Malformed config: {path}") from e
```

### Logging Best Practices
- Use structured logging with appropriate levels
- Include context in log messages
- Never log sensitive information
- Use f-strings for log formatting (lazy evaluation)

```python
logger.info(f"Processing {len(items)} items from {source}")
logger.debug(f"Configuration loaded: {config.keys()}")
logger.warning(f"Retrying operation {attempt}/{max_attempts}")
logger.error(f"Failed to process item {item_id}: {error}")
```

## Documentation Standards

### Docstring Requirements
- **Every public function, class, and module must have docstrings**
- Use Google-style docstrings for consistency
- Include examples for complex functions
- Document exceptions that may be raised

```python
def calculate_metrics(
    data: pd.DataFrame, 
    groupby_cols: list[str],
    metric_cols: list[str]
) -> dict[str, pd.Series]:
    """Calculate summary metrics for grouped data.
    
    Args:
        data: DataFrame containing the data to analyze
        groupby_cols: Columns to group by
        metric_cols: Columns to calculate metrics for
        
    Returns:
        Dictionary mapping metric names to Series with calculated values
        
    Raises:
        ValueError: If required columns are missing from data
        
    Example:
        >>> df = pd.DataFrame({'group': ['A', 'B'], 'value': [1, 2]})
        >>> calculate_metrics(df, ['group'], ['value'])
        {'mean': group\nA    1.0\nB    2.0\nName: value, dtype: float64}
    """
```

### Code Comments
- Write comments that explain **why**, not what
- Use TODO/FIXME/NOTE comments for future improvements
- Keep comments up-to-date with code changes

## Code Organization & Architecture

### Project Structure
```
project/
├── src/
│   └── myproject/
│       ├── __init__.py
│       ├── core/           # Core business logic
│       ├── models/         # Data models
│       ├── services/       # Service layer
│       ├── utils/          # Utility functions
│       └── config/         # Configuration
├── tests/                  # Test modules mirror src/
├── docs/                   # Documentation
└── pyproject.toml         # Project configuration
```

### Module Design
- **Check for existing functionality before creating new code**
- **Follow existing patterns in the codebase**
- **Reuse and extend existing utilities**
- Keep modules focused and cohesive (single responsibility)
- Avoid circular imports through careful dependency design

### Function Design
- Functions should do one thing well
- Keep functions small (generally < 20 lines)
- Use pure functions when possible (no side effects)
- Prefer composition over inheritance

## Implementation Guidelines

### Development Workflow
1. **Understand the existing codebase** - Read related code first
2. **Start with the simplest solution** that works
3. **Write tests alongside implementation** (TDD approach)
4. **One feature/function at a time** - incremental development
5. **Refactor in small steps** with tests validating each change
6. **Ask before major architectural changes**

### Code Quality Checks
- Use `black` for formatting
- Use `isort` for import sorting  
- Use `flake8` or `ruff` for linting
- Use `mypy` for type checking
- Use `pytest` for testing
- Configure pre-commit hooks for consistency

### Performance Considerations
- Profile before optimizing
- Use appropriate data structures (list vs set vs dict)
- Consider memory usage for large datasets
- Use generators for large iterations
- Cache expensive operations when appropriate

## Testing Standards

### Test Structure
```python
import pytest
from unittest.mock import Mock, patch

def test_function_name_describes_scenario():
    """Test that function handles normal input correctly."""
    # Arrange
    input_data = {"key": "value"}
    expected = "processed_value"
    
    # Act
    result = function_under_test(input_data)
    
    # Assert
    assert result == expected

def test_function_name_handles_edge_case():
    """Test that function raises appropriate error for invalid input."""
    with pytest.raises(ValueError, match="Invalid input"):
        function_under_test(invalid_input)
```

### Test Coverage
- Aim for >90% code coverage
- Test happy paths and edge cases
- Test error conditions and exception handling
- Use property-based testing for complex logic

## Security & Best Practices

### Security Considerations
- Never hardcode secrets or credentials
- Use environment variables for configuration
- Validate and sanitize all inputs
- Use parameterized queries for database operations
- Keep dependencies updated

### Code Review Checklist
- [ ] Follows PEP 8 and project conventions
- [ ] Has comprehensive type hints
- [ ] Includes proper error handling
- [ ] Has docstrings and comments
- [ ] Reuses existing functionality
- [ ] Includes tests
- [ ] No security vulnerabilities
- [ ] Performance considerations addressed

## Tools Configuration

### pyproject.toml example
```toml
[tool.black]
line-length = 88
target-version = ["py311"]

[tool.isort]
profile = "black"
multi_line_output = 3

[tool.mypy]
python_version = "3.11"
strict = true
warn_return_any = true
warn_unused_configs = true

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
```

## Common Anti-Patterns to Avoid

- **Duplicating existing functionality** instead of reusing
- Using `import *` (pollutes namespace)
- Catching and ignoring exceptions silently
- Using mutable default arguments
- String concatenation in loops (use join or f-strings)
- Not using context managers for resource management
- Premature optimization
- God classes/functions (too many responsibilities)

Remember: **Readable code is maintainable code. When in doubt, choose clarity over cleverness.**
