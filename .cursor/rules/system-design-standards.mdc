---
alwaysApply: true
---

# Professional System Design Standards

## Core Design Principles

### 1. Scalability & Performance
- **Design for horizontal scaling** from day one
- **Implement caching strategies** at multiple levels (application, database, CDN)
- **Use asynchronous processing** for I/O-bound operations
- **Optimize database queries** and implement proper indexing
- **Consider microservices architecture** for complex systems
- **Implement rate limiting** and request throttling

### 2. Reliability & Fault Tolerance
- **Design for failure** - assume components will fail
- **Implement circuit breakers** for external service calls
- **Use retry mechanisms** with exponential backoff
- **Implement health checks** and monitoring
- **Design for graceful degradation** when services are unavailable
- **Use idempotent operations** where possible

### 3. Security by Design
- **Implement defense in depth** - multiple security layers
- **Use secure authentication** and authorization (OAuth 2.0, JWT)
- **Encrypt data at rest and in transit** (TLS 1.3, AES-256)
- **Implement input validation** and sanitization
- **Use secure coding practices** (OWASP guidelines)
- **Implement audit logging** for security events

### 4. Maintainability & Observability
- **Design for observability** - logging, metrics, tracing
- **Implement structured logging** with correlation IDs
- **Use distributed tracing** (OpenTelemetry, Jaeger)
- **Design for testability** - dependency injection, mocking
- **Implement feature flags** for safe deployments
- **Use configuration management** (environment variables, config files)

## Architecture Patterns

### Service-Oriented Architecture
```python
# Example: Service layer with dependency injection
from abc import ABC, abstractmethod
from typing import Protocol
import logging

logger = logging.getLogger(__name__)

class DataRepository(Protocol):
    """Data access interface."""
    def get_data(self, id: str) -> dict:
        ...
    def save_data(self, data: dict) -> bool:
        ...

class ExternalServiceClient(Protocol):
    """External service interface."""
    def call_service(self, payload: dict) -> dict:
        ...

class BusinessService:
    """Business logic service with dependencies."""
    
    def __init__(
        self, 
        data_repo: DataRepository,
        external_client: ExternalServiceClient,
        cache_client: CacheClient
    ):
        self.data_repo = data_repo
        self.external_client = external_client
        self.cache_client = cache_client
        self.logger = logging.getLogger(__name__)
    
    def process_business_logic(self, request_id: str) -> dict:
        """Process business logic with proper error handling and logging."""
        try:
            # Check cache first
            cached_result = self.cache_client.get(request_id)
            if cached_result:
                self.logger.info(f"Cache hit for request {request_id}")
                return cached_result
            
            # Get data from repository
            data = self.data_repo.get_data(request_id)
            if not data:
                raise ValueError(f"Data not found for request {request_id}")
            
            # Call external service
            result = self.external_client.call_service(data)
            
            # Cache the result
            self.cache_client.set(request_id, result, ttl=3600)
            
            self.logger.info(f"Successfully processed request {request_id}")
            return result
            
        except Exception as e:
            self.logger.error(f"Error processing request {request_id}: {e}")
            raise
```

### Event-Driven Architecture
```python
# Example: Event-driven system with message queue
from typing import Any, Callable
import json
import asyncio
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Event:
    """Event structure for event-driven architecture."""
    event_type: str
    payload: dict
    timestamp: datetime
    correlation_id: str
    source: str

class EventBus:
    """Event bus for decoupled communication."""
    
    def __init__(self):
        self.handlers: dict[str, list[Callable]] = {}
        self.logger = logging.getLogger(__name__)
    
    def subscribe(self, event_type: str, handler: Callable[[Event], None]):
        """Subscribe to an event type."""
        if event_type not in self.handlers:
            self.handlers[event_type] = []
        self.handlers[event_type].append(handler)
    
    async def publish(self, event: Event):
        """Publish an event to all subscribers."""
        self.logger.info(f"Publishing event {event.event_type} with correlation ID {event.correlation_id}")
        
        if event.event_type in self.handlers:
            for handler in self.handlers[event.event_type]:
                try:
                    await handler(event)
                except Exception as e:
                    self.logger.error(f"Error in event handler: {e}")

class OrderService:
    """Service that publishes events."""
    
    def __init__(self, event_bus: EventBus):
        self.event_bus = event_bus
        self.logger = logging.getLogger(__name__)
    
    async def create_order(self, order_data: dict) -> dict:
        """Create order and publish events."""
        # Create order logic here
        order_id = "order_123"
        
        # Publish order created event
        event = Event(
            event_type="order.created",
            payload={"order_id": order_id, "data": order_data},
            timestamp=datetime.utcnow(),
            correlation_id=order_id,
            source="order_service"
        )
        
        await self.event_bus.publish(event)
        return {"order_id": order_id}
```

## Database Design Patterns

### Repository Pattern
```python
from abc import ABC, abstractmethod
from typing import Generic, TypeVar, Optional, List
from sqlalchemy.orm import Session
from sqlalchemy import create_engine
import logging

T = TypeVar('T')

class BaseRepository(ABC, Generic[T]):
    """Base repository interface."""
    
    @abstractmethod
    def create(self, entity: T) -> T:
        pass
    
    @abstractmethod
    def get_by_id(self, id: str) -> Optional[T]:
        pass
    
    @abstractmethod
    def update(self, entity: T) -> T:
        pass
    
    @abstractmethod
    def delete(self, id: str) -> bool:
        pass

class SQLAlchemyRepository(BaseRepository[T]):
    """SQLAlchemy implementation of repository pattern."""
    
    def __init__(self, session: Session, model_class: type[T]):
        self.session = session
        self.model_class = model_class
        self.logger = logging.getLogger(__name__)
    
    def create(self, entity: T) -> T:
        """Create a new entity."""
        try:
            self.session.add(entity)
            self.session.commit()
            self.logger.info(f"Created {self.model_class.__name__} with ID {getattr(entity, 'id', 'unknown')}")
            return entity
        except Exception as e:
            self.session.rollback()
            self.logger.error(f"Error creating {self.model_class.__name__}: {e}")
            raise
    
    def get_by_id(self, id: str) -> Optional[T]:
        """Get entity by ID."""
        return self.session.query(self.model_class).filter_by(id=id).first()
```

### Data Access Layer
```python
# Example: Connection pooling and transaction management
from contextlib import contextmanager
from typing import Generator
import psycopg2
from psycopg2.pool import SimpleConnectionPool
import logging

logger = logging.getLogger(__name__)

class DatabaseManager:
    """Database connection and transaction management."""
    
    def __init__(self, connection_string: str, min_connections: int = 5, max_connections: int = 20):
        self.connection_string = connection_string
        self.pool = SimpleConnectionPool(
            min_connections, 
            max_connections, 
            connection_string
        )
        self.logger = logging.getLogger(__name__)
    
    @contextmanager
    def get_connection(self) -> Generator[psycopg2.extensions.connection, None, None]:
        """Get a database connection from the pool."""
        conn = self.pool.getconn()
        try:
            yield conn
        except Exception as e:
            self.logger.error(f"Database error: {e}")
            conn.rollback()
            raise
        finally:
            self.pool.putconn(conn)
    
    @contextmanager
    def transaction(self) -> Generator[psycopg2.extensions.connection, None, None]:
        """Get a database connection with transaction management."""
        with self.get_connection() as conn:
            try:
                yield conn
                conn.commit()
            except Exception:
                conn.rollback()
                raise
```

## API Design Standards

### RESTful API Design
```python
from fastapi import FastAPI, HTTPException, Depends, status
from pydantic import BaseModel, Field
from typing import List, Optional
import logging

logger = logging.getLogger(__name__)

app = FastAPI(
    title="Professional API",
    description="Production-ready API with proper error handling and validation",
    version="1.0.0"
)

class UserCreate(BaseModel):
    """User creation request model."""
    email: str = Field(..., description="User email address")
    name: str = Field(..., min_length=1, max_length=100, description="User full name")
    role: str = Field(default="user", description="User role")

class UserResponse(BaseModel):
    """User response model."""
    id: str
    email: str
    name: str
    role: str
    created_at: str

@app.post("/users", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(user: UserCreate):
    """Create a new user with proper validation and error handling."""
    try:
        # Business logic here
        user_id = "user_123"
        
        logger.info(f"Created user {user_id} with email {user.email}")
        
        return UserResponse(
            id=user_id,
            email=user.email,
            name=user.name,
            role=user.role,
            created_at="2024-01-01T00:00:00Z"
        )
    except ValueError as e:
        logger.error(f"Validation error creating user: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Unexpected error creating user: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error"
        )
```

### GraphQL API Design
```python
import strawberry
from typing import List, Optional
from datetime import datetime

@strawberry.type
class User:
    """User GraphQL type."""
    id: str
    email: str
    name: str
    role: str
    created_at: datetime

@strawberry.input
class CreateUserInput:
    """User creation input."""
    email: str
    name: str
    role: Optional[str] = "user"

@strawberry.type
class Query:
    """GraphQL query type."""
    
    @strawberry.field
    def user(self, id: str) -> Optional[User]:
        """Get user by ID."""
        # Implementation here
        pass
    
    @strawberry.field
    def users(self, limit: int = 10, offset: int = 0) -> List[User]:
        """Get paginated list of users."""
        # Implementation here
        pass

@strawberry.type
class Mutation:
    """GraphQL mutation type."""
    
    @strawberry.mutation
    def create_user(self, input: CreateUserInput) -> User:
        """Create a new user."""
        # Implementation here
        pass

schema = strawberry.Schema(query=Query, mutation=Mutation)
```

## Configuration Management

### Environment Configuration
```python
from pydantic import BaseSettings, Field
from typing import Optional
import os

class DatabaseSettings(BaseSettings):
    """Database configuration."""
    host: str = Field(..., env="DB_HOST")
    port: int = Field(5432, env="DB_PORT")
    database: str = Field(..., env="DB_NAME")
    username: str = Field(..., env="DB_USER")
    password: str = Field(..., env="DB_PASSWORD")
    pool_size: int = Field(10, env="DB_POOL_SIZE")
    
    class Config:
        env_file = ".env"

class APISettings(BaseSettings):
    """API configuration."""
    host: str = Field("0.0.0.0", env="API_HOST")
    port: int = Field(8000, env="API_PORT")
    debug: bool = Field(False, env="DEBUG")
    secret_key: str = Field(..., env="SECRET_KEY")
    cors_origins: list[str] = Field(["http://localhost:3000"], env="CORS_ORIGINS")
    
    class Config:
        env_file = ".env"

class Settings(BaseSettings):
    """Application settings."""
    database: DatabaseSettings = DatabaseSettings()
    api: APISettings = APISettings()
    environment: str = Field("development", env="ENVIRONMENT")
    log_level: str = Field("INFO", env="LOG_LEVEL")

settings = Settings()
```

## Monitoring & Observability

### Structured Logging
```python
import logging
import json
from datetime import datetime
from typing import Any, Dict
import uuid

class StructuredLogger:
    """Structured logging with correlation IDs."""
    
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self.correlation_id = str(uuid.uuid4())
    
    def _log(self, level: str, message: str, **kwargs):
        """Log with structured data."""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": level,
            "message": message,
            "correlation_id": self.correlation_id,
            "service": "my_service",
            **kwargs
        }
        
        self.logger.log(
            getattr(logging, level.upper()),
            json.dumps(log_entry)
        )
    
    def info(self, message: str, **kwargs):
        self._log("INFO", message, **kwargs)
    
    def error(self, message: str, **kwargs):
        self._log("ERROR", message, **kwargs)
    
    def warning(self, message: str, **kwargs):
        self._log("WARNING", message, **kwargs)

# Usage
logger = StructuredLogger(__name__)
logger.info("Processing request", user_id="123", action="create_order")
```

### Health Checks
```python
from fastapi import FastAPI
from typing import Dict, Any
import psycopg2
import redis
import requests

app = FastAPI()

@app.get("/health")
async def health_check() -> Dict[str, Any]:
    """Comprehensive health check endpoint."""
    health_status = {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "services": {}
    }
    
    # Database health check
    try:
        # Database check logic
        health_status["services"]["database"] = "healthy"
    except Exception as e:
        health_status["services"]["database"] = f"unhealthy: {e}"
        health_status["status"] = "unhealthy"
    
    # Redis health check
    try:
        # Redis check logic
        health_status["services"]["redis"] = "healthy"
    except Exception as e:
        health_status["services"]["redis"] = f"unhealthy: {e}"
        health_status["status"] = "unhealthy"
    
    # External service health check
    try:
        # External service check logic
        health_status["services"]["external_service"] = "healthy"
    except Exception as e:
        health_status["services"]["external_service"] = f"unhealthy: {e}"
        health_status["status"] = "unhealthy"
    
    return health_status
```

## Security Implementation

### Authentication & Authorization
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt
from typing import Optional
from datetime import datetime, timedelta

security = HTTPBearer()

class AuthService:
    """Authentication and authorization service."""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.algorithm = "HS256"
    
    def create_access_token(self, data: dict, expires_delta: Optional[timedelta] = None):
        """Create JWT access token."""
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=15)
        
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        return encoded_jwt
    
    def verify_token(self, token: str) -> dict:
        """Verify JWT token."""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token has expired"
            )
        except jwt.JWTError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token"
            )

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Dependency to get current authenticated user."""
    auth_service = AuthService("your-secret-key")
    payload = auth_service.verify_token(credentials.credentials)
    return payload
```

## Deployment & DevOps

### Docker Configuration
```dockerfile
# Multi-stage build for production
FROM python:3.11-slim as builder

WORKDIR /app

# Install build dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir --user -r requirements.txt

# Production stage
FROM python:3.11-slim

WORKDIR /app

# Create non-root user
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Copy Python packages from builder
COPY --from=builder /root/.local /root/.local

# Copy application code
COPY . .

# Set permissions
RUN chown -R appuser:appuser /app

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Run application
CMD ["python", "-m", "uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### Docker Compose for Development
```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/mydb
      - REDIS_URL=redis://redis:6379
      - ENVIRONMENT=development
    depends_on:
      - db
      - redis
    volumes:
      - .:/app
    command: python -m uvicorn main:app --host 0.0.0.0 --port 8000 --reload

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=mydb
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - app

volumes:
  postgres_data:
```

## Testing Strategy

### Integration Testing
```python
import pytest
from fastapi.testclient import TestClient
from unittest.mock import Mock, patch
import asyncio

class TestAPIIntegration:
    """Integration tests for API endpoints."""
    
    @pytest.fixture
    def client(self):
        """Test client fixture."""
        from main import app
        return TestClient(app)
    
    @pytest.fixture
    def mock_database(self):
        """Mock database fixture."""
        with patch('app.database.get_connection') as mock:
            yield mock
    
    def test_create_user_success(self, client, mock_database):
        """Test successful user creation."""
        user_data = {
            "email": "test@example.com",
            "name": "Test User",
            "role": "user"
        }
        
        response = client.post("/users", json=user_data)
        
        assert response.status_code == 201
        assert response.json()["email"] == user_data["email"]
    
    def test_create_user_validation_error(self, client):
        """Test user creation with invalid data."""
        user_data = {
            "email": "invalid-email",
            "name": "",
            "role": "invalid_role"
        }
        
        response = client.post("/users", json=user_data)
        
        assert response.status_code == 422
```

## Performance Optimization

### Caching Strategy
```python
from functools import wraps
import redis
import json
import hashlib
from typing import Any, Optional

class CacheManager:
    """Redis-based cache manager."""
    
    def __init__(self, redis_url: str):
        self.redis_client = redis.from_url(redis_url)
    
    def cache(self, ttl: int = 3600):
        """Cache decorator for function results."""
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                # Create cache key
                key_data = f"{func.__name__}:{args}:{kwargs}"
                cache_key = hashlib.md5(key_data.encode()).hexdigest()
                
                # Try to get from cache
                cached_result = self.redis_client.get(cache_key)
                if cached_result:
                    return json.loads(cached_result)
                
                # Execute function and cache result
                result = func(*args, **kwargs)
                self.redis_client.setex(
                    cache_key, 
                    ttl, 
                    json.dumps(result)
                )
                
                return result
            return wrapper
        return decorator

# Usage
cache_manager = CacheManager("redis://localhost:6379")

@cache_manager.cache(ttl=1800)
def get_user_profile(user_id: str) -> dict:
    """Get user profile with caching."""
    # Expensive database query here
    return {"user_id": user_id, "name": "John Doe"}
```

## Error Handling & Resilience

### Circuit Breaker Pattern
```python
import asyncio
from enum import Enum
from datetime import datetime, timedelta
from typing import Callable, Any
import logging

logger = logging.getLogger(__name__)

class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

class CircuitBreaker:
    """Circuit breaker implementation."""
    
    def __init__(
        self,
        failure_threshold: int = 5,
        recovery_timeout: int = 60,
        expected_exception: type = Exception
    ):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.expected_exception = expected_exception
        
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.last_failure_time = None
    
    async def call(self, func: Callable, *args, **kwargs) -> Any:
        """Execute function with circuit breaker protection."""
        if self.state == CircuitState.OPEN:
            if datetime.now() - self.last_failure_time > timedelta(seconds=self.recovery_timeout):
                self.state = CircuitState.HALF_OPEN
                logger.info("Circuit breaker transitioning to half-open state")
            else:
                raise Exception("Circuit breaker is open")
        
        try:
            result = await func(*args, **kwargs)
            self._on_success()
            return result
        except self.expected_exception as e:
            self._on_failure()
            raise
    
    def _on_success(self):
        """Handle successful execution."""
        self.failure_count = 0
        self.state = CircuitState.CLOSED
        logger.info("Circuit breaker reset to closed state")
    
    def _on_failure(self):
        """Handle failed execution."""
        self.failure_count += 1
        self.last_failure_time = datetime.now()
        
        if self.failure_count >= self.failure_threshold:
            self.state = CircuitState.OPEN
            logger.warning(f"Circuit breaker opened after {self.failure_count} failures")

# Usage
circuit_breaker = CircuitBreaker(failure_threshold=3, recovery_timeout=30)

async def external_api_call():
    """External API call with circuit breaker protection."""
    return await circuit_breaker.call(
        lambda: requests.get("https://api.example.com/data")
    )
```

## Best Practices Checklist

### Architecture Design
- [ ] **Scalability**: Design for horizontal scaling
- [ ] **Reliability**: Implement fault tolerance patterns
- [ ] **Security**: Security by design principles
- [ ] **Maintainability**: Clean architecture and SOLID principles
- [ ] **Observability**: Comprehensive logging and monitoring
- [ ] **Testability**: Design for easy testing

### Code Quality
- [ ] **Type Safety**: Comprehensive type hints
- [ ] **Error Handling**: Proper exception management
- [ ] **Documentation**: Clear API documentation
- [ ] **Testing**: Unit, integration, and E2E tests
- [ ] **Code Review**: Peer review process
- [ ] **Static Analysis**: Linting and type checking

### Security
- [ ] **Authentication**: Secure user authentication
- [ ] **Authorization**: Role-based access control
- [ ] **Input Validation**: Sanitize all inputs
- [ ] **Encryption**: Data encryption at rest and in transit
- [ ] **Audit Logging**: Security event logging
- [ ] **Dependency Management**: Regular security updates

### Performance
- [ ] **Caching**: Multi-level caching strategy
- [ ] **Database Optimization**: Proper indexing and queries
- [ ] **Async Processing**: Non-blocking operations
- [ ] **Resource Management**: Connection pooling
- [ ] **Monitoring**: Performance metrics tracking
- [ ] **Load Testing**: Performance validation

### Operations
- [ ] **Deployment**: Automated CI/CD pipeline
- [ ] **Monitoring**: Health checks and alerting
- [ ] **Logging**: Structured logging with correlation IDs
- [ ] **Configuration**: Environment-based configuration
- [ ] **Backup**: Data backup and recovery
- [ ] **Disaster Recovery**: Business continuity planning

Remember: **Production-ready systems are built with reliability, security, and maintainability as first-class concerns. Always design for failure and plan for scale.**
# Professional System Design Standards

## Core Design Principles

### 1. Scalability & Performance
- **Design for horizontal scaling** from day one
- **Implement caching strategies** at multiple levels (application, database, CDN)
- **Use asynchronous processing** for I/O-bound operations
- **Optimize database queries** and implement proper indexing
- **Consider microservices architecture** for complex systems
- **Implement rate limiting** and request throttling

### 2. Reliability & Fault Tolerance
- **Design for failure** - assume components will fail
- **Implement circuit breakers** for external service calls
- **Use retry mechanisms** with exponential backoff
- **Implement health checks** and monitoring
- **Design for graceful degradation** when services are unavailable
- **Use idempotent operations** where possible

### 3. Security by Design
- **Implement defense in depth** - multiple security layers
- **Use secure authentication** and authorization (OAuth 2.0, JWT)
- **Encrypt data at rest and in transit** (TLS 1.3, AES-256)
- **Implement input validation** and sanitization
- **Use secure coding practices** (OWASP guidelines)
- **Implement audit logging** for security events

### 4. Maintainability & Observability
- **Design for observability** - logging, metrics, tracing
- **Implement structured logging** with correlation IDs
- **Use distributed tracing** (OpenTelemetry, Jaeger)
- **Design for testability** - dependency injection, mocking
- **Implement feature flags** for safe deployments
- **Use configuration management** (environment variables, config files)

## Architecture Patterns

### Service-Oriented Architecture
```python
# Example: Service layer with dependency injection
from abc import ABC, abstractmethod
from typing import Protocol
import logging

logger = logging.getLogger(__name__)

class DataRepository(Protocol):
    """Data access interface."""
    def get_data(self, id: str) -> dict:
        ...
    def save_data(self, data: dict) -> bool:
        ...

class ExternalServiceClient(Protocol):
    """External service interface."""
    def call_service(self, payload: dict) -> dict:
        ...

class BusinessService:
    """Business logic service with dependencies."""
    
    def __init__(
        self, 
        data_repo: DataRepository,
        external_client: ExternalServiceClient,
        cache_client: CacheClient
    ):
        self.data_repo = data_repo
        self.external_client = external_client
        self.cache_client = cache_client
        self.logger = logging.getLogger(__name__)
    
    def process_business_logic(self, request_id: str) -> dict:
        """Process business logic with proper error handling and logging."""
        try:
            # Check cache first
            cached_result = self.cache_client.get(request_id)
            if cached_result:
                self.logger.info(f"Cache hit for request {request_id}")
                return cached_result
            
            # Get data from repository
            data = self.data_repo.get_data(request_id)
            if not data:
                raise ValueError(f"Data not found for request {request_id}")
            
            # Call external service
            result = self.external_client.call_service(data)
            
            # Cache the result
            self.cache_client.set(request_id, result, ttl=3600)
            
            self.logger.info(f"Successfully processed request {request_id}")
            return result
            
        except Exception as e:
            self.logger.error(f"Error processing request {request_id}: {e}")
            raise
```

### Event-Driven Architecture
```python
# Example: Event-driven system with message queue
from typing import Any, Callable
import json
import asyncio
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Event:
    """Event structure for event-driven architecture."""
    event_type: str
    payload: dict
    timestamp: datetime
    correlation_id: str
    source: str

class EventBus:
    """Event bus for decoupled communication."""
    
    def __init__(self):
        self.handlers: dict[str, list[Callable]] = {}
        self.logger = logging.getLogger(__name__)
    
    def subscribe(self, event_type: str, handler: Callable[[Event], None]):
        """Subscribe to an event type."""
        if event_type not in self.handlers:
            self.handlers[event_type] = []
        self.handlers[event_type].append(handler)
    
    async def publish(self, event: Event):
        """Publish an event to all subscribers."""
        self.logger.info(f"Publishing event {event.event_type} with correlation ID {event.correlation_id}")
        
        if event.event_type in self.handlers:
            for handler in self.handlers[event.event_type]:
                try:
                    await handler(event)
                except Exception as e:
                    self.logger.error(f"Error in event handler: {e}")

class OrderService:
    """Service that publishes events."""
    
    def __init__(self, event_bus: EventBus):
        self.event_bus = event_bus
        self.logger = logging.getLogger(__name__)
    
    async def create_order(self, order_data: dict) -> dict:
        """Create order and publish events."""
        # Create order logic here
        order_id = "order_123"
        
        # Publish order created event
        event = Event(
            event_type="order.created",
            payload={"order_id": order_id, "data": order_data},
            timestamp=datetime.utcnow(),
            correlation_id=order_id,
            source="order_service"
        )
        
        await self.event_bus.publish(event)
        return {"order_id": order_id}
```

## Database Design Patterns

### Repository Pattern
```python
from abc import ABC, abstractmethod
from typing import Generic, TypeVar, Optional, List
from sqlalchemy.orm import Session
from sqlalchemy import create_engine
import logging

T = TypeVar('T')

class BaseRepository(ABC, Generic[T]):
    """Base repository interface."""
    
    @abstractmethod
    def create(self, entity: T) -> T:
        pass
    
    @abstractmethod
    def get_by_id(self, id: str) -> Optional[T]:
        pass
    
    @abstractmethod
    def update(self, entity: T) -> T:
        pass
    
    @abstractmethod
    def delete(self, id: str) -> bool:
        pass

class SQLAlchemyRepository(BaseRepository[T]):
    """SQLAlchemy implementation of repository pattern."""
    
    def __init__(self, session: Session, model_class: type[T]):
        self.session = session
        self.model_class = model_class
        self.logger = logging.getLogger(__name__)
    
    def create(self, entity: T) -> T:
        """Create a new entity."""
        try:
            self.session.add(entity)
            self.session.commit()
            self.logger.info(f"Created {self.model_class.__name__} with ID {getattr(entity, 'id', 'unknown')}")
            return entity
        except Exception as e:
            self.session.rollback()
            self.logger.error(f"Error creating {self.model_class.__name__}: {e}")
            raise
    
    def get_by_id(self, id: str) -> Optional[T]:
        """Get entity by ID."""
        return self.session.query(self.model_class).filter_by(id=id).first()
```

### Data Access Layer
```python
# Example: Connection pooling and transaction management
from contextlib import contextmanager
from typing import Generator
import psycopg2
from psycopg2.pool import SimpleConnectionPool
import logging

logger = logging.getLogger(__name__)

class DatabaseManager:
    """Database connection and transaction management."""
    
    def __init__(self, connection_string: str, min_connections: int = 5, max_connections: int = 20):
        self.connection_string = connection_string
        self.pool = SimpleConnectionPool(
            min_connections, 
            max_connections, 
            connection_string
        )
        self.logger = logging.getLogger(__name__)
    
    @contextmanager
    def get_connection(self) -> Generator[psycopg2.extensions.connection, None, None]:
        """Get a database connection from the pool."""
        conn = self.pool.getconn()
        try:
            yield conn
        except Exception as e:
            self.logger.error(f"Database error: {e}")
            conn.rollback()
            raise
        finally:
            self.pool.putconn(conn)
    
    @contextmanager
    def transaction(self) -> Generator[psycopg2.extensions.connection, None, None]:
        """Get a database connection with transaction management."""
        with self.get_connection() as conn:
            try:
                yield conn
                conn.commit()
            except Exception:
                conn.rollback()
                raise
```

## API Design Standards

### RESTful API Design
```python
from fastapi import FastAPI, HTTPException, Depends, status
from pydantic import BaseModel, Field
from typing import List, Optional
import logging

logger = logging.getLogger(__name__)

app = FastAPI(
    title="Professional API",
    description="Production-ready API with proper error handling and validation",
    version="1.0.0"
)

class UserCreate(BaseModel):
    """User creation request model."""
    email: str = Field(..., description="User email address")
    name: str = Field(..., min_length=1, max_length=100, description="User full name")
    role: str = Field(default="user", description="User role")

class UserResponse(BaseModel):
    """User response model."""
    id: str
    email: str
    name: str
    role: str
    created_at: str

@app.post("/users", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(user: UserCreate):
    """Create a new user with proper validation and error handling."""
    try:
        # Business logic here
        user_id = "user_123"
        
        logger.info(f"Created user {user_id} with email {user.email}")
        
        return UserResponse(
            id=user_id,
            email=user.email,
            name=user.name,
            role=user.role,
            created_at="2024-01-01T00:00:00Z"
        )
    except ValueError as e:
        logger.error(f"Validation error creating user: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Unexpected error creating user: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error"
        )
```

### GraphQL API Design
```python
import strawberry
from typing import List, Optional
from datetime import datetime

@strawberry.type
class User:
    """User GraphQL type."""
    id: str
    email: str
    name: str
    role: str
    created_at: datetime

@strawberry.input
class CreateUserInput:
    """User creation input."""
    email: str
    name: str
    role: Optional[str] = "user"

@strawberry.type
class Query:
    """GraphQL query type."""
    
    @strawberry.field
    def user(self, id: str) -> Optional[User]:
        """Get user by ID."""
        # Implementation here
        pass
    
    @strawberry.field
    def users(self, limit: int = 10, offset: int = 0) -> List[User]:
        """Get paginated list of users."""
        # Implementation here
        pass

@strawberry.type
class Mutation:
    """GraphQL mutation type."""
    
    @strawberry.mutation
    def create_user(self, input: CreateUserInput) -> User:
        """Create a new user."""
        # Implementation here
        pass

schema = strawberry.Schema(query=Query, mutation=Mutation)
```

## Configuration Management

### Environment Configuration
```python
from pydantic import BaseSettings, Field
from typing import Optional
import os

class DatabaseSettings(BaseSettings):
    """Database configuration."""
    host: str = Field(..., env="DB_HOST")
    port: int = Field(5432, env="DB_PORT")
    database: str = Field(..., env="DB_NAME")
    username: str = Field(..., env="DB_USER")
    password: str = Field(..., env="DB_PASSWORD")
    pool_size: int = Field(10, env="DB_POOL_SIZE")
    
    class Config:
        env_file = ".env"

class APISettings(BaseSettings):
    """API configuration."""
    host: str = Field("0.0.0.0", env="API_HOST")
    port: int = Field(8000, env="API_PORT")
    debug: bool = Field(False, env="DEBUG")
    secret_key: str = Field(..., env="SECRET_KEY")
    cors_origins: list[str] = Field(["http://localhost:3000"], env="CORS_ORIGINS")
    
    class Config:
        env_file = ".env"

class Settings(BaseSettings):
    """Application settings."""
    database: DatabaseSettings = DatabaseSettings()
    api: APISettings = APISettings()
    environment: str = Field("development", env="ENVIRONMENT")
    log_level: str = Field("INFO", env="LOG_LEVEL")

settings = Settings()
```

## Monitoring & Observability

### Structured Logging
```python
import logging
import json
from datetime import datetime
from typing import Any, Dict
import uuid

class StructuredLogger:
    """Structured logging with correlation IDs."""
    
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self.correlation_id = str(uuid.uuid4())
    
    def _log(self, level: str, message: str, **kwargs):
        """Log with structured data."""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": level,
            "message": message,
            "correlation_id": self.correlation_id,
            "service": "my_service",
            **kwargs
        }
        
        self.logger.log(
            getattr(logging, level.upper()),
            json.dumps(log_entry)
        )
    
    def info(self, message: str, **kwargs):
        self._log("INFO", message, **kwargs)
    
    def error(self, message: str, **kwargs):
        self._log("ERROR", message, **kwargs)
    
    def warning(self, message: str, **kwargs):
        self._log("WARNING", message, **kwargs)

# Usage
logger = StructuredLogger(__name__)
logger.info("Processing request", user_id="123", action="create_order")
```

### Health Checks
```python
from fastapi import FastAPI
from typing import Dict, Any
import psycopg2
import redis
import requests

app = FastAPI()

@app.get("/health")
async def health_check() -> Dict[str, Any]:
    """Comprehensive health check endpoint."""
    health_status = {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "services": {}
    }
    
    # Database health check
    try:
        # Database check logic
        health_status["services"]["database"] = "healthy"
    except Exception as e:
        health_status["services"]["database"] = f"unhealthy: {e}"
        health_status["status"] = "unhealthy"
    
    # Redis health check
    try:
        # Redis check logic
        health_status["services"]["redis"] = "healthy"
    except Exception as e:
        health_status["services"]["redis"] = f"unhealthy: {e}"
        health_status["status"] = "unhealthy"
    
    # External service health check
    try:
        # External service check logic
        health_status["services"]["external_service"] = "healthy"
    except Exception as e:
        health_status["services"]["external_service"] = f"unhealthy: {e}"
        health_status["status"] = "unhealthy"
    
    return health_status
```

## Security Implementation

### Authentication & Authorization
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt
from typing import Optional
from datetime import datetime, timedelta

security = HTTPBearer()

class AuthService:
    """Authentication and authorization service."""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.algorithm = "HS256"
    
    def create_access_token(self, data: dict, expires_delta: Optional[timedelta] = None):
        """Create JWT access token."""
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=15)
        
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        return encoded_jwt
    
    def verify_token(self, token: str) -> dict:
        """Verify JWT token."""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token has expired"
            )
        except jwt.JWTError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token"
            )

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Dependency to get current authenticated user."""
    auth_service = AuthService("your-secret-key")
    payload = auth_service.verify_token(credentials.credentials)
    return payload
```

## Deployment & DevOps

### Docker Configuration
```dockerfile
# Multi-stage build for production
FROM python:3.11-slim as builder

WORKDIR /app

# Install build dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir --user -r requirements.txt

# Production stage
FROM python:3.11-slim

WORKDIR /app

# Create non-root user
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Copy Python packages from builder
COPY --from=builder /root/.local /root/.local

# Copy application code
COPY . .

# Set permissions
RUN chown -R appuser:appuser /app

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Run application
CMD ["python", "-m", "uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### Docker Compose for Development
```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/mydb
      - REDIS_URL=redis://redis:6379
      - ENVIRONMENT=development
    depends_on:
      - db
      - redis
    volumes:
      - .:/app
    command: python -m uvicorn main:app --host 0.0.0.0 --port 8000 --reload

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=mydb
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - app

volumes:
  postgres_data:
```

## Testing Strategy

### Integration Testing
```python
import pytest
from fastapi.testclient import TestClient
from unittest.mock import Mock, patch
import asyncio

class TestAPIIntegration:
    """Integration tests for API endpoints."""
    
    @pytest.fixture
    def client(self):
        """Test client fixture."""
        from main import app
        return TestClient(app)
    
    @pytest.fixture
    def mock_database(self):
        """Mock database fixture."""
        with patch('app.database.get_connection') as mock:
            yield mock
    
    def test_create_user_success(self, client, mock_database):
        """Test successful user creation."""
        user_data = {
            "email": "test@example.com",
            "name": "Test User",
            "role": "user"
        }
        
        response = client.post("/users", json=user_data)
        
        assert response.status_code == 201
        assert response.json()["email"] == user_data["email"]
    
    def test_create_user_validation_error(self, client):
        """Test user creation with invalid data."""
        user_data = {
            "email": "invalid-email",
            "name": "",
            "role": "invalid_role"
        }
        
        response = client.post("/users", json=user_data)
        
        assert response.status_code == 422
```

## Performance Optimization

### Caching Strategy
```python
from functools import wraps
import redis
import json
import hashlib
from typing import Any, Optional

class CacheManager:
    """Redis-based cache manager."""
    
    def __init__(self, redis_url: str):
        self.redis_client = redis.from_url(redis_url)
    
    def cache(self, ttl: int = 3600):
        """Cache decorator for function results."""
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                # Create cache key
                key_data = f"{func.__name__}:{args}:{kwargs}"
                cache_key = hashlib.md5(key_data.encode()).hexdigest()
                
                # Try to get from cache
                cached_result = self.redis_client.get(cache_key)
                if cached_result:
                    return json.loads(cached_result)
                
                # Execute function and cache result
                result = func(*args, **kwargs)
                self.redis_client.setex(
                    cache_key, 
                    ttl, 
                    json.dumps(result)
                )
                
                return result
            return wrapper
        return decorator

# Usage
cache_manager = CacheManager("redis://localhost:6379")

@cache_manager.cache(ttl=1800)
def get_user_profile(user_id: str) -> dict:
    """Get user profile with caching."""
    # Expensive database query here
    return {"user_id": user_id, "name": "John Doe"}
```

## Error Handling & Resilience

### Circuit Breaker Pattern
```python
import asyncio
from enum import Enum
from datetime import datetime, timedelta
from typing import Callable, Any
import logging

logger = logging.getLogger(__name__)

class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

class CircuitBreaker:
    """Circuit breaker implementation."""
    
    def __init__(
        self,
        failure_threshold: int = 5,
        recovery_timeout: int = 60,
        expected_exception: type = Exception
    ):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.expected_exception = expected_exception
        
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.last_failure_time = None
    
    async def call(self, func: Callable, *args, **kwargs) -> Any:
        """Execute function with circuit breaker protection."""
        if self.state == CircuitState.OPEN:
            if datetime.now() - self.last_failure_time > timedelta(seconds=self.recovery_timeout):
                self.state = CircuitState.HALF_OPEN
                logger.info("Circuit breaker transitioning to half-open state")
            else:
                raise Exception("Circuit breaker is open")
        
        try:
            result = await func(*args, **kwargs)
            self._on_success()
            return result
        except self.expected_exception as e:
            self._on_failure()
            raise
    
    def _on_success(self):
        """Handle successful execution."""
        self.failure_count = 0
        self.state = CircuitState.CLOSED
        logger.info("Circuit breaker reset to closed state")
    
    def _on_failure(self):
        """Handle failed execution."""
        self.failure_count += 1
        self.last_failure_time = datetime.now()
        
        if self.failure_count >= self.failure_threshold:
            self.state = CircuitState.OPEN
            logger.warning(f"Circuit breaker opened after {self.failure_count} failures")

# Usage
circuit_breaker = CircuitBreaker(failure_threshold=3, recovery_timeout=30)

async def external_api_call():
    """External API call with circuit breaker protection."""
    return await circuit_breaker.call(
        lambda: requests.get("https://api.example.com/data")
    )
```

## Best Practices Checklist

### Architecture Design
- [ ] **Scalability**: Design for horizontal scaling
- [ ] **Reliability**: Implement fault tolerance patterns
- [ ] **Security**: Security by design principles
- [ ] **Maintainability**: Clean architecture and SOLID principles
- [ ] **Observability**: Comprehensive logging and monitoring
- [ ] **Testability**: Design for easy testing

### Code Quality
- [ ] **Type Safety**: Comprehensive type hints
- [ ] **Error Handling**: Proper exception management
- [ ] **Documentation**: Clear API documentation
- [ ] **Testing**: Unit, integration, and E2E tests
- [ ] **Code Review**: Peer review process
- [ ] **Static Analysis**: Linting and type checking

### Security
- [ ] **Authentication**: Secure user authentication
- [ ] **Authorization**: Role-based access control
- [ ] **Input Validation**: Sanitize all inputs
- [ ] **Encryption**: Data encryption at rest and in transit
- [ ] **Audit Logging**: Security event logging
- [ ] **Dependency Management**: Regular security updates

### Performance
- [ ] **Caching**: Multi-level caching strategy
- [ ] **Database Optimization**: Proper indexing and queries
- [ ] **Async Processing**: Non-blocking operations
- [ ] **Resource Management**: Connection pooling
- [ ] **Monitoring**: Performance metrics tracking
- [ ] **Load Testing**: Performance validation

### Operations
- [ ] **Deployment**: Automated CI/CD pipeline
- [ ] **Monitoring**: Health checks and alerting
- [ ] **Logging**: Structured logging with correlation IDs
- [ ] **Configuration**: Environment-based configuration
- [ ] **Backup**: Data backup and recovery
- [ ] **Disaster Recovery**: Business continuity planning

Remember: **Production-ready systems are built with reliability, security, and maintainability as first-class concerns. Always design for failure and plan for scale.**
